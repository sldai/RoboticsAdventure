"""
Reeds Shepp curve implementation.
Ref: the paper https://msp.org/pjm/1990/145-2/p06.xhtml
     reference code https://github.com/nathanlct/reeds-shepp-curves
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from enum import Enum


def M(theta):
    """
    Return the angle phi = theta mod (2 pi) such that -pi <= theta < pi.
    """
    theta = theta % (2*math.pi)
    if theta >= math.pi:
        theta -= 2*math.pi
    return theta


def R(x, y):
    """
    Return the polar coordinates (r, theta) of the point (x, y).
    """
    r = math.sqrt(x*x + y*y)
    theta = math.atan2(y, x)
    return r, theta

def circle_move(x, y, theta, R, alpha):
    """The car moves alpha rad along a circle with radius R
    Args:
        x, y, yaw: start configuration
        R: radius
        alpha: angle [rad]

    Returns:
        x_n, y_n, yaw_n: end configuration 
    """
    dtheta = alpha
    theta_1 = theta
    theta_2 = theta_1 + dtheta
    dx = -R*math.sin(theta_1) + R*math.sin(theta_2)
    dy = R*math.cos(theta_1) - R*math.cos(theta_2)
    x_n = x + dx
    y_n = y + dy
    theta_n = theta + dtheta
    return x_n, y_n, theta_n


class Steering(Enum):
    LEFT = 1
    RIGHT = 2
    STRAIGHT = 3


class Gear(Enum):
    FORWARD = 1
    BACKWARD = 2


class PathElement():
    def __init__(self, param, steering, gear):
        self.param = param
        self.steering = steering
        self.gear = gear

    def __repr__(self):
        if self.steering == Steering.LEFT:
            steering_str = "left"
        elif self.steering == Steering.RIGHT:
            steering_str = "right"
        else:
            steering_str = "straight"

        if self.gear == Gear.FORWARD:
            gear_str = "forward"
        else:
            gear_str = "backward"

        s = "{ Steering: " + steering_str + "\tGear: " + gear_str \
            + "\tdistance: " + str(round(self.param, 2)) + " }"

        return s

    def reverse_steering(self):
        if self.steering == Steering.LEFT:
            self.steering = Steering.RIGHT
        elif self.steering == Steering.RIGHT:
            self.steering = Steering.LEFT

    def reverse_gear(self):
        if self.gear == Gear.FORWARD:
            self.gear = Gear.BACKWARD
        else:
            self.gear = Gear.FORWARD


class ReedsShepp(object):
    def __init__(self, sx, sy, syaw, gx, gy, gyaw, max_curvature, step_size):
        self.sx = sx
        self.sy = sy
        self.syaw = syaw
        self.max_curvature = max_curvature
        self.step_size = step_size

        # transform configurations into body frame
        rot = np.array(
            [[np.cos(syaw), -np.sin(syaw)],
             [np.sin(syaw), np.cos(syaw)]]
        )
        p = np.array([sx, sy]).reshape((2, 1))
        T = np.block(
            [[rot, p],
             [np.zeros((1, 2)), 1]]
        )
        bG = np.linalg.inv(T) @ np.array([gx, gy, 1.0])
        bx, by, btheta = bG[0], bG[1], gyaw-syaw

        bx = bx * max_curvature  # scale coordinates
        by = by * max_curvature  # so the new max radius is 1

        norm_paths = self.__get_all_path(bx, by, btheta)
        def sum_pathsegs(path): return sum([seg.param for seg in path])
        path_lengths = np.array([sum_pathsegs(path) for path in norm_paths])
        min_ind = np.argmin(path_lengths)
        self.optimal_norm_path = norm_paths[min_ind]
        self.norm_paths = norm_paths

    def __get_all_path(self, bx, by, btheta):
        """
        Return a list of all the paths from start to end generated by the
        12 functions and their variants
        """
        path_fns = [path1, path2, path3, path4, path5, path6,
                    path7, path8, path9, path10, path11, path12]
        paths = []
        for get_path in path_fns:
            # get the four variants for each path type, cf article
            paths.append(get_path(bx, by, btheta))
            paths.append(timeflip(get_path(-bx, by, -btheta)))
            paths.append(reflect(get_path(bx, -by, -btheta)))
            paths.append(reflect(timeflip(get_path(-bx, -by, btheta))))

        # remove empty paths
        paths = list(filter(None, paths))

        # remove path elements that have parameter 0
        for i in range(len(paths)):
            paths[i] = list(filter(lambda e: e.param != 0, paths[i]))

        return paths

    def __move_segment(self, seg, sx, sy, syaw, param=None):
        """The move result of one normalized segment and normalized value. sx, sy, syaw are not normalized
        """
        if param is None:
            param = seg.param
        gx, gy, gyaw = None, None, None
        if seg.steering == Steering.STRAIGHT:
            d = param * 1.0/self.max_curvature
            if seg.gear == Gear.BACKWARD:
                d = -d
            gx = sx+d*np.cos(syaw)
            gy = sy+d*np.sin(syaw)
            gyaw = syaw

        else:
            R = 1.0/self.max_curvature
            alpha = param

            if seg.steering == Steering.LEFT and seg.gear == Gear.FORWARD:
                R = R
                alpha = alpha
            elif seg.steering == Steering.RIGHT and seg.gear == Gear.FORWARD:
                R = -R
                alpha = -alpha
            elif seg.steering == Steering.LEFT and seg.gear == Gear.BACKWARD:
                R = R
                alpha = -alpha
            elif seg.steering == Steering.RIGHT and seg.gear == Gear.BACKWARD:
                R = -R
                alpha = alpha
            gx, gy, gyaw = circle_move(sx, sy, syaw, R, alpha)
        return gx, gy, gyaw

    def __get_path_from_ind(self, ind=None):
        """Specify the desired path with index.
        None indicates the optimal path
        """
        if ind is None:
            path = self.optimal_norm_path
        else:
            assert 0 <= ind < len(self.norm_paths), 'Path index out of range'
            path = self.norm_paths[ind]
        return path

    def calc_path_length(self, ind=None):
        norm_path = self.__get_path_from_ind(ind)
        length = sum([seg.param for seg in norm_path]) * 1.0/self.max_curvature
        return length

    def calc_config(self, s, ind=None):
        """calculate (x,y,yaw) = f(s), s is the scalar position for path[ind]
        """
        norm_path = self.__get_path_from_ind(ind)
        if s < 0 or s > self.calc_path_length(ind):
            return None
        s = s*self.max_curvature
        cx, cy, cyaw = self.sx, self.sy, self.syaw
        c_curv = 0.0

        for seg_ind, seg in enumerate(norm_path):
            if s > seg.param:
                cx, cy, cyaw = self.__move_segment(
                    seg, cx, cy, cyaw, seg.param)
                s = s-seg.param
            else:
                cx, cy, cyaw = self.__move_segment(seg, cx, cy, cyaw, s)
                s = 0.0
                if seg.steering == Steering.STRAIGHT:
                    c_curv = 0.0
                elif seg.steering == Steering.LEFT:
                    c_curv = self.max_curvature
                elif seg.steering == Steering.RIGHT:
                    c_curv = -self.max_curvature
                break

        return cx, cy, cyaw, c_curv

    def get_optimal_path(self):
        """Get the optimal path
        Returns:
            waypoints (n * 4 array): n = path_length/step_size
            the column [x, y, yaw, curvature] 
        """
        max_s = self.calc_path_length()
        s_list = np.arange(start=0, stop=max_s, step=self.step_size)
        waypoints = np.array([self.calc_config(s) for s in s_list])
        return waypoints

    def get_all_paths(self):
        """Get all potential optimal paths
        Returns:
            paths_list (list): a list of paths, the path format see get_optimal_path()
        """
        paths_list = []
        for ind in range(len(self.norm_paths)):
            max_s = self.calc_path_length(ind)
            s_list = np.arange(start=0, stop=max_s, step=self.step_size)
            waypoints = np.array([self.calc_config(s, ind) for s in s_list])
            paths_list.append(waypoints)
        return paths_list

################ timeflip and reflect operation, ################
################ see https://msp.org/pjm/1990/145-2/p06.xhtml ###


def timeflip(path):
    """
    timeflip transform described around the end of the article
    """
    new_path = path.copy()
    for e in new_path:
        e.reverse_gear()
    return new_path


def reflect(path):
    """
    reflect transform described around the end of the article
    """
    new_path = path.copy()
    for e in new_path:
        e.reverse_steering()
    return new_path

################# 12 words ###########################


def path1(x, y, phi):
    """
    Formula 8.1: CSC (same turns)
    """
    r, theta = R(x, y)
    path = []

    u, t = R(x - math.sin(phi), y - 1 + math.cos(phi))
    v = M(phi - t)

    if t >= 0 and u >= 0 and v >= 0:
        path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement(u, Steering.STRAIGHT, Gear.FORWARD))
        path.append(PathElement(v, Steering.LEFT, Gear.FORWARD))

    return path


def path2(x, y, phi):
    """
    Formula 8.2: CSC (opposite turns)
    """
    r, theta = R(x, y)
    path = []

    rho, t1 = R(x + math.sin(phi), y - 1 - math.cos(phi))

    if rho * rho >= 4:
        u = math.sqrt(rho * rho - 4)
        t = M(t1 + math.atan2(2, u))
        v = M(t - phi)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.STRAIGHT, Gear.FORWARD))
            path.append(PathElement(v, Steering.RIGHT, Gear.FORWARD))

    return path


def path3(x, y, phi):
    """
    Formula 8.3: C|C|C
    """
    r, theta = R(x, y)
    path = []

    xi = x - math.sin(phi)
    eta = y - 1 + math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4:
        A = math.acos(rho / 4)
        t = M(theta + math.pi/2 + A)
        u = M(math.pi - 2*A)
        v = M(phi - t - u)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.RIGHT, Gear.BACKWARD))
            path.append(PathElement(v, Steering.LEFT, Gear.FORWARD))

    return path


def path4(x, y, phi):
    """
    Formula 8.4 (1): C|CC
    """
    r, theta = R(x, y)
    path = []

    xi = x - math.sin(phi)
    eta = y - 1 + math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4:
        A = math.acos(rho / 4)
        t = M(theta + math.pi/2 + A)
        u = M(math.pi - 2*A)
        v = M(t + u - phi)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.RIGHT, Gear.BACKWARD))
            path.append(PathElement(v, Steering.LEFT, Gear.BACKWARD))

    return path


def path5(x, y, phi):
    """
    Formula 8.4 (2): CC|C
    """
    r, theta = R(x, y)
    path = []

    xi = x - math.sin(phi)
    eta = y - 1 + math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4:
        u = math.acos(1 - rho*rho/8)
        A = math.asin(2 * math.sin(u) / rho)
        t = M(theta + math.pi/2 - A)
        v = M(t - u - phi)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.RIGHT, Gear.FORWARD))
            path.append(PathElement(v, Steering.LEFT, Gear.BACKWARD))

    return path


def path6(x, y, phi):
    """
    Formula 8.7: CCu|CuC
    """
    r, theta = R(x, y)
    path = []

    xi = x + math.sin(phi)
    eta = y - 1 - math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4:
        if rho <= 2:
            A = math.acos((rho + 2) / 4)
            t = M(theta + math.pi/2 + A)
            u = M(A)
            v = M(phi - t + 2*u)
        else:
            A = math.acos((rho - 2) / 4)
            t = M(theta + math.pi/2 - A)
            u = M(math.pi - A)
            v = M(phi - t + 2*u)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.RIGHT, Gear.FORWARD))
            path.append(PathElement(u, Steering.LEFT, Gear.BACKWARD))
            path.append(PathElement(v, Steering.RIGHT, Gear.BACKWARD))

    return path


def path7(x, y, phi):
    """
    Formula 8.8: C|CuCu|C
    """
    r, theta = R(x, y)
    path = []

    xi = x + math.sin(phi)
    eta = y - 1 - math.cos(phi)
    rho, theta = R(xi, eta)
    u1 = (20 - rho*rho) / 16

    if rho <= 6 and 0 <= u1 and u1 <= 1:
        u = math.acos(u1)
        A = math.asin(2 * math.sin(u) / rho)
        t = M(theta + math.pi/2 + A)
        v = M(t - phi)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.RIGHT, Gear.BACKWARD))
            path.append(PathElement(u, Steering.LEFT, Gear.BACKWARD))
            path.append(PathElement(v, Steering.RIGHT, Gear.FORWARD))

    return path


def path8(x, y, phi):
    """
    Formula 8.9 (1): C|C[pi/2]SC
    """
    r, theta = R(x, y)
    path = []

    xi = x - math.sin(phi)
    eta = y - 1 + math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2:
        u = math.sqrt(rho*rho - 4) - 2
        A = math.atan2(2, u+2)
        t = M(theta + math.pi/2 + A)
        v = M(t - phi + math.pi/2)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(math.pi/2, Steering.RIGHT, Gear.BACKWARD))
            path.append(PathElement(u, Steering.STRAIGHT, Gear.BACKWARD))
            path.append(PathElement(v, Steering.LEFT, Gear.BACKWARD))

    return path


def path9(x, y, phi):
    """
    Formula 8.9 (2): CSC[pi/2]|C
    """
    r, theta = R(x, y)
    path = []

    xi = x - math.sin(phi)
    eta = y - 1 + math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2:
        u = math.sqrt(rho*rho - 4) - 2
        A = math.atan2(u+2, 2)
        t = M(theta + math.pi/2 - A)
        v = M(t - phi - math.pi/2)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.STRAIGHT, Gear.FORWARD))
            path.append(PathElement(math.pi/2, Steering.RIGHT, Gear.FORWARD))
            path.append(PathElement(v, Steering.LEFT, Gear.BACKWARD))

    return path


def path10(x, y, phi):
    """
    Formula 8.10 (1): C|C[pi/2]SC
    """
    r, theta = R(x, y)
    path = []

    xi = x + math.sin(phi)
    eta = y - 1 - math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2:
        t = M(theta + math.pi/2)
        u = rho - 2
        v = M(phi - t - math.pi/2)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(math.pi/2, Steering.RIGHT, Gear.BACKWARD))
            path.append(PathElement(u, Steering.STRAIGHT, Gear.BACKWARD))
            path.append(PathElement(v, Steering.RIGHT, Gear.BACKWARD))

    return path


def path11(x, y, phi):
    """
    Formula 8.10 (2): CSC[pi/2]|C
    """
    r, theta = R(x, y)
    path = []

    xi = x + math.sin(phi)
    eta = y - 1 - math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2:
        t = M(theta)
        u = rho - 2
        v = M(phi - t - math.pi/2)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.STRAIGHT, Gear.FORWARD))
            path.append(PathElement(math.pi/2, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(v, Steering.RIGHT, Gear.BACKWARD))

    return path


def path12(x, y, phi):
    """
    Formula 8.11: C|C[pi/2]SC[pi/2]|C
    """
    r, theta = R(x, y)
    path = []

    xi = x + math.sin(phi)
    eta = y - 1 - math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 4:
        u = math.sqrt(rho*rho - 4) - 4
        A = math.atan2(2, u+4)
        t = M(theta + math.pi/2 + A)
        v = M(t - phi)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(math.pi/2, Steering.RIGHT, Gear.BACKWARD))
            path.append(PathElement(u, Steering.STRAIGHT, Gear.BACKWARD))
            path.append(PathElement(math.pi/2, Steering.LEFT, Gear.BACKWARD))
            path.append(PathElement(v, Steering.RIGHT, Gear.FORWARD))

    return path

################### end rs words ##########################


import draw
def main():
    PATH = [(0, 0, 0), (10, 10, -90), (20, 5, 60), (30, 10, 120),
           (35, -5, 30), (25, -10, -120), (15, -15, 100), (0, -10, -90)]

    for i in range(len(PATH) - 1):
        sx, sy, syaw = PATH[i]
        gx, gy, gyaw = PATH[i+1]
        syaw = math.radians(syaw)
        gyaw = math.radians(gyaw)
        rs = ReedsShepp(sx, sy, syaw, gx, gy, gyaw, 1.0/4, 0.1)
        paths = rs.get_all_paths()
        # for path in paths:
        #     plt.plot(path[:, 0], path[:, 1])
        opt_path = rs.get_optimal_path()
        plt.plot(opt_path[:,0], opt_path[:,1], linewidth=1, color='gray')

    for x, y, theta in PATH:
        draw.Arrow(x, y, np.deg2rad(theta), 2, 'blueviolet')
    plt.xlabel('X [m]')
    plt.ylabel('Y [m]')
    plt.title('Reeds Shepp curve')
    plt.axis("equal")
    plt.show()


if __name__ == "__main__":
    main()
