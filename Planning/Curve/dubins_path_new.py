"""
Reeds Shepp curve implementation.
Ref: the paper https://msp.org/pjm/1990/145-2/p06.xhtml
     reference code https://github.com/nathanlct/reeds-shepp-curves
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from enum import Enum


def M(theta):
    """
    Return the angle phi = theta mod (2 pi) such that -pi <= theta < pi.
    """
    theta = theta % (2*math.pi)
    if theta >= math.pi:
        theta -= 2*math.pi
    return theta


def R(x, y):
    """
    Return the polar coordinates (r, theta) of the point (x, y).
    """
    r = math.sqrt(x*x + y*y)
    theta = math.atan2(y, x)
    return r, theta

def circle_move(x, y, theta, R, alpha):
    """The car moves alpha rad along a circle with radius R
    Args:
        x, y, yaw: start configuration
        R: radius
        alpha: angle [rad]

    Returns:
        x_n, y_n, yaw_n: end configuration 
    """
    dtheta = alpha
    theta_1 = theta
    theta_2 = theta_1 + dtheta
    dx = -R*math.sin(theta_1) + R*math.sin(theta_2)
    dy = R*math.cos(theta_1) - R*math.cos(theta_2)
    x_n = x + dx
    y_n = y + dy
    theta_n = theta + dtheta
    return x_n, y_n, theta_n


class Steering(Enum):
    LEFT = 1
    RIGHT = 2
    STRAIGHT = 3


class Gear(Enum):
    FORWARD = 1
    BACKWARD = 2


class PathElement():
    def __init__(self, param, steering, gear):
        self.param = param
        self.steering = steering
        self.gear = gear

    def __repr__(self):
        if self.steering == Steering.LEFT:
            steering_str = "left"
        elif self.steering == Steering.RIGHT:
            steering_str = "right"
        else:
            steering_str = "straight"

        if self.gear == Gear.FORWARD:
            gear_str = "forward"
        else:
            gear_str = "backward"

        s = "{ Steering: " + steering_str + "\tGear: " + gear_str \
            + "\tdistance: " + str(round(self.param, 2)) + " }"

        return s

    def reverse_steering(self):
        if self.steering == Steering.LEFT:
            self.steering = Steering.RIGHT
        elif self.steering == Steering.RIGHT:
            self.steering = Steering.LEFT

    def reverse_gear(self):
        if self.gear == Gear.FORWARD:
            self.gear = Gear.BACKWARD
        else:
            self.gear = Gear.FORWARD


class ReedsShepp(object):
    def __init__(self, sx, sy, syaw, gx, gy, gyaw, max_curvature, step_size):
        self.sx = sx
        self.sy = sy
        self.syaw = syaw
        self.max_curvature = max_curvature
        self.step_size = step_size

        # transform configurations into body frame
        rot = np.array(
            [[np.cos(syaw), -np.sin(syaw)],
             [np.sin(syaw), np.cos(syaw)]]
        )
        p = np.array([sx, sy]).reshape((2, 1))
        T = np.block(
            [[rot, p],
             [np.zeros((1, 2)), 1]]
        )
        bG = np.linalg.inv(T) @ np.array([gx, gy, 1.0])
        bx, by, btheta = bG[0], bG[1], gyaw-syaw

        bx = bx * max_curvature  # scale coordinates
        by = by * max_curvature  # so the new max radius is 1

        norm_paths = self.__get_all_path(bx, by, btheta)
        def sum_pathsegs(path): return sum([seg.param for seg in path])
        path_lengths = np.array([sum_pathsegs(path) for path in norm_paths])
        min_ind = np.argmin(path_lengths)
        self.optimal_norm_path = norm_paths[min_ind]
        self.norm_paths = norm_paths

    def __get_all_path(self, bx, by, btheta):
        """
        Return a list of all the paths from start to end generated by the
        12 functions and their variants
        """
        path_fns = [path1, path2, path3, path4, path5, path6,
                    path7, path8, path9, path10, path11, path12]
        paths = []
        for get_path in path_fns:
            # get the four variants for each path type, cf article
            paths.append(get_path(bx, by, btheta))
            paths.append(timeflip(get_path(-bx, by, -btheta)))
            paths.append(reflect(get_path(bx, -by, -btheta)))
            paths.append(reflect(timeflip(get_path(-bx, -by, btheta))))

        # remove empty paths
        paths = list(filter(None, paths))

        # remove path elements that have parameter 0
        for i in range(len(paths)):
            paths[i] = list(filter(lambda e: e.param != 0, paths[i]))

        return paths

    def __move_segment(self, seg, sx, sy, syaw, param=None):
        """The move result of one normalized segment and normalized value. sx, sy, syaw are not normalized
        """
        if param is None:
            param = seg.param
        gx, gy, gyaw = None, None, None
        if seg.steering == Steering.STRAIGHT:
            d = param * 1.0/self.max_curvature
            if seg.gear == Gear.BACKWARD:
                d = -d
            gx = sx+d*np.cos(syaw)
            gy = sy+d*np.sin(syaw)
            gyaw = syaw

        else:
            R = 1.0/self.max_curvature
            alpha = param

            if seg.steering == Steering.LEFT and seg.gear == Gear.FORWARD:
                R = R
                alpha = alpha
            elif seg.steering == Steering.RIGHT and seg.gear == Gear.FORWARD:
                R = -R
                alpha = -alpha
            elif seg.steering == Steering.LEFT and seg.gear == Gear.BACKWARD:
                R = R
                alpha = -alpha
            elif seg.steering == Steering.RIGHT and seg.gear == Gear.BACKWARD:
                R = -R
                alpha = alpha
            gx, gy, gyaw = circle_move(sx, sy, syaw, R, alpha)
        return gx, gy, gyaw

    def __get_path_from_ind(self, ind=None):
        """Specify the desired path with index.
        None indicates the optimal path
        """
        if ind is None:
            path = self.optimal_norm_path
        else:
            assert 0 <= ind < len(self.norm_paths), 'Path index out of range'
            path = self.norm_paths[ind]
        return path

    def calc_path_length(self, ind=None):
        norm_path = self.__get_path_from_ind(ind)
        length = sum([seg.param for seg in norm_path]) * 1.0/self.max_curvature
        return length

    def calc_config(self, s, ind=None):
        """calculate (x,y,yaw) = f(s), s is the scalar position for path[ind]
        """
        norm_path = self.__get_path_from_ind(ind)
        if s < 0 or s > self.calc_path_length(ind):
            return None
        s = s*self.max_curvature
        cx, cy, cyaw = self.sx, self.sy, self.syaw
        c_curv = 0.0

        for seg_ind, seg in enumerate(norm_path):
            if s > seg.param:
                cx, cy, cyaw = self.__move_segment(
                    seg, cx, cy, cyaw, seg.param)
                s = s-seg.param
            else:
                cx, cy, cyaw = self.__move_segment(seg, cx, cy, cyaw, s)
                s = 0.0
                if seg.steering == Steering.STRAIGHT:
                    c_curv = 0.0
                elif seg.steering == Steering.LEFT:
                    c_curv = self.max_curvature
                elif seg.steering == Steering.RIGHT:
                    c_curv = -self.max_curvature
                break

        return cx, cy, cyaw, c_curv

    def get_optimal_path(self):
        """Get the optimal path
        Returns:
            waypoints (n * 4 array): n = path_length/step_size
            the column [x, y, yaw, curvature] 
        """
        max_s = self.calc_path_length()
        s_list = np.arange(start=0, stop=max_s, step=self.step_size)
        waypoints = np.array([self.calc_config(s) for s in s_list])
        return waypoints

    def get_all_paths(self):
        """Get all potential optimal paths
        Returns:
            paths_list (list): a list of paths, the path format see get_optimal_path()
        """
        paths_list = []
        for ind in range(len(self.norm_paths)):
            max_s = self.calc_path_length(ind)
            s_list = np.arange(start=0, stop=max_s, step=self.step_size)
            waypoints = np.array([self.calc_config(s, ind) for s in s_list])
            paths_list.append(waypoints)
        return paths_list

################ timeflip and reflect operation, ################
################ see https://msp.org/pjm/1990/145-2/p06.xhtml ###


def timeflip(path):
    """
    timeflip transform described around the end of the article
    """
    new_path = path.copy()
    for e in new_path:
        e.reverse_gear()
    return new_path


def reflect(path):
    """
    reflect transform described around the end of the article
    """
    new_path = path.copy()
    for e in new_path:
        e.reverse_steering()
    return new_path

################# 12 words ###########################


def path1(x, y, phi):
    """
    Formula 8.1: CSC (same turns)
    i.e. LSL
    """
    r, theta = R(x, y)
    path = []

    u, t = R(x - math.sin(phi), y - 1 + math.cos(phi))
    v = M(phi - t)

    if t >= 0 and u >= 0 and v >= 0:
        path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement(u, Steering.STRAIGHT, Gear.FORWARD))
        path.append(PathElement(v, Steering.LEFT, Gear.FORWARD))

    return path


def path2(x, y, phi):
    """
    Formula 8.2: CSC (opposite turns)
    i.e. LSR
    """
    r, theta = R(x, y)
    path = []

    rho, t1 = R(x + math.sin(phi), y - 1 - math.cos(phi))

    if rho * rho >= 4:
        u = math.sqrt(rho * rho - 4)
        t = M(t1 + math.atan2(2, u))
        v = M(t - phi)

        if t >= 0 and u >= 0 and v >= 0:
            path.append(PathElement(t, Steering.LEFT, Gear.FORWARD))
            path.append(PathElement(u, Steering.STRAIGHT, Gear.FORWARD))
            path.append(PathElement(v, Steering.RIGHT, Gear.FORWARD))
    return path

def LRL(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)

    rec = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_b - sin_a)) / 8.0

    if abs(rec) > 1.0:
        return None, None, None, ["L", "R", "L"]

    p_lrl = mod2pi(2 * math.pi - math.acos(rec))
    t_lrl = mod2pi(-alpha - math.atan2(cos_a - cos_b, dist + sin_a - sin_b) + p_lrl / 2.0)
    q_lrl = mod2pi(mod2pi(beta) - alpha - t_lrl + mod2pi(p_lrl))

    return t_lrl, p_lrl, q_lrl, ["L", "R", "L"]
    
################### end rs words ##########################

def main():
    # points to be followed
    pts = [(-6, -7), (-6, 0), (-4, 6), (0, 5),
           (0, -2), (-2, -6), (3, -5), (3, 6), (6, 4)]

    # generate PATH so the vectors are pointing at each other
    PATH = []
    for i in range(len(pts) - 1):
        dx = pts[i+1][0] - pts[i][0]
        dy = pts[i+1][1] - pts[i][1]
        theta = math.atan2(dy, dx)
        PATH.append((pts[i][0], pts[i][1], theta))
    PATH.append((pts[-1][0], pts[-1][1], 0))

    for i in range(len(PATH) - 1):
        sx, sy, syaw = PATH[i]
        gx, gy, gyaw = PATH[i+1]

        rs = ReedsShepp(sx, sy, syaw, gx, gy, gyaw, 1.0, 0.1)
        paths = rs.get_all_paths()
        for path in paths:
            plt.plot(path[:, 0], path[:, 1])
        opt_path = rs.get_optimal_path()
        plt.plot(opt_path[:,0], opt_path[:,1], linewidth=2, color='r')
    plt.axis("equal")
    plt.show()


if __name__ == "__main__":
    main()
